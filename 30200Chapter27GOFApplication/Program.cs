using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _30200Chapter27GOFApplication
{
    class Program
    {
        static void Main(string[] args)
        {
        }
    }

    //第二十七章 GOF总结

    /*
     * GOF给我们最大的其实就是把紧密引用在一起的对象通过抽象或增加第三个对象的方法拆解得更加松散。它的前提还是那句经典的----唯一不变的是变化本身----。
     * 
     * 经过一系列模式的学习我们会发现设计的步骤比较类似：
     * 1，分析面临的问题，把其中关键对象的静态结构（采用类图）和动态结构（采用时序图）表示出来。该步骤让我们从具体的业务环境抽象到软件领域。
     * 2，找到其中变化的部分，分析是哪个对象在导致相关的变化，尤其是那些自身变化会导致相关依赖对象变动的对象。
     * 3，如果对象的不确定性来自于构造过程，那么可以借助创建型模式。控制目标对象的数量，或这把创工作交给一个独立的对象完成。这样逻辑处理对象本身就不会因为构造对其他一系列对象产生直接依赖。不过事先该目标前提就是待构造的对象本身被作了一次抽象。
     * 4，如果对象的不确定来自类型结构，那么就要考虑结构性模式。一个相对抽象的对象把其他结构上产生依赖的对象组织在一起。
     * 5，如果不确定性来自执行过程，那么可以考虑行为型模式。行为型模式很多时候是对应用复杂性的进一步分解，比如某些操作，交互过程过于复杂，那么行为型的思维方法就是增加新的对象，把这些操作和交互对象化。
     */
}
