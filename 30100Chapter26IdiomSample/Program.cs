using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _30100Chapter26IdiomSample
{
    class Program
    {
        static void Main(string[] args)
        {
        }
    }

    //第二十六章 成例

    /*
     * Partial class 体现组合关系
     * 
     */

    /*
     * Gateway 封装一些底层API操作，将Gateway IGateway化，就特化成了适配器模式
     * 
     * 结构型模式封装方法与Gateway的比较
     * 1,Facade外观模式，包装模式：此模式视为了封装一个子系统。但在使用过程中，包装模式大部分是面向服务端需要封装的，而网关模式一般用于客户端服务封装的
     * 
     * 2，适配器模式：适配机器模式可视为特定约定的严格的网关模式
     * 
     * 3，中介器模式：它主要解决的是过个对象的问题
     * 
     * 
     * Gateway应用场景：
     * 1，封装直接与Windows平台的API交互
     * 2，封装遗留系统
     * 3，封装特定技术领域系统，从C#开发的角度考虑，可以用不同的网关封装XML访问，SQL访问，正则表达式访问，Javascript
     * 4，根据业务语义和操作方便的考虑，封装一些相对公共的接口
     * 5，觉得以前的实现别扭，但不愿重写，可以抱一个习惯点的类型
     * 6，封装非C#语言访问接口
     * 7，封装通用操作方法 
     */


    /*
     * Mapper
     * 1，为了不影响A,B两个系统，又不希望客户程序直接与这两个系统产生引用，所以就只好找到第三个对象——映射器，他按照客户程序的使用需求包装设计A,B两个系统的交互性操作。
     * .....
     * 
     * 数据对象映射器 ORM object-relation mapping:基于XML
     * 
     * 小结：
     * 项目中常用三个映射器模式：
     * Data Mapper，File Mapper，XML Mapper
     * 1，Data Mapper一般负责实体对象和关系数据库的交互
     * 
     * 2，File Mapper往往负责类型系统与I/O的交互
     * 
     * 3，XML Mapper往往要在两个XSD实体间进行操作
     */


    /*
     *Registry
     *
     * 应用中往往需要找到某某对象的问题，如果每类对象都设计一个类似IStore，IDictionary似乎成本比较高，而且应用往往还需要访问不同类型对象，则时候也需要一个全局的注册表。
     * 
     * 
     * 全局只是个相对概念：
     * 
     * 1，Windows的注册表是某台计算机范围内的。
     * 2，配置文件中依赖倒置原则所定义的那些Qualified Type名称及对应名称接口的描述一般是进程级的。
     * 3，单件模式中，对并发应用或.NET WEB开发中，往往还需要一个线程或HttpContext范围内的相对"全局"的注册表。
     * 4，可以减少重复性定义工作
     * 5，便于不同对象的全局性信息访问
     * 6，不用没得类慈宁宫定义自己的static属性（可能的话，尽量不要定义static属性，毕竟难于多态特性应用上去，并发条件下如何处理争用恐怕也需要每个类型反复考虑类似的问题）
     * 7，放在一个大家都知道的地方以后即便增加新的类型，也可以比较方便地找到。
     * 8，集中管理的需要。
     * 
     * 
     *                                                interface
     *                                  /----(聚合)----IDictionary<key,value>
     * utility                   interface
     * Registries----（组合）----IRegistry----(聚合)----interface
     *                                                  IList<T>
     * 
     * Registries：可以就设计成一个静态类。它应该是进程全局的。它的作用是帮助客户程序作为第一步的盗号，找到某个需要的IRegistry。但它并不是必要的
     */



    /*
     * 
     * 通用数据载体DataSet和DataTable
     * 
     * 对于.NET开发人员而言，DataSet有如下优势
     * 1，使用Offline的内存数据库
     * 2，可以装载多个DataTable
     * 3，与XML天然继承
     * 4，有比较完善的内存数据筛选，查询机制
     * 5，同时可以维护多个数据对象间的关联关系
     * 6，尤其对于两层的数据应用而言，提供了完善的数据使用周期的支持
     * 
     * 
     * 
     * DataSet或DataTable不利的方面
     * 1，数据业务语义不甚清楚，客户程序必须了解字段的组成才能提取字段项
     * 2，传输中有很多多余的信息在传递
     * 3，弱类型数据结构不如强类型的数据结构实体使用方便
     * 4，容量有限制
     * 5，并非标准的数据结构
     */


    /*
     * Context
     * 与之前在注册表模式看到的内容有些像是，上下文模式也是用来保存一组相关信息的数据结构，只不过它更多的保存的是和调用信息相关的内容。
     * 它站在调用栈的旁边，一直伴随着调用栈的执行过程。
     * 项目实现上，可以采用一个IDictionary来保存一些列Key/Value，但关键是Context保存在什么位置才可以让桌面应用也好，Web应用也好都能比价方便的访问，同时可以有效隔离与其他调用栈的管理。
     * 
     * 第二章设计了一个通用个Generic Context
     * 
     * 
     * 
     * 使用Context模式的好处！
     * 1，类似注册表模式，可以把一些原本需要设计为参数的在调用栈中传来传去的内容省略，这样可以令接口设计更加整齐一些。
     * 2，编译进一步分跨调用关系的对象进行交互，相应的内容都根据Key保存在一个Context中
     * 3，Context本身不像注册表，更具当前Session或Thread动态地创建或释放，尤其适合那些间歇性服务的引用
     * 4，为进一步嵌入调用过程提供必要的调用上下文公共数据的存放和提取机制
     */



}
